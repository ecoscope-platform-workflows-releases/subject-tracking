# AUTOGENERATED BY ECOSCOPE-WORKFLOWS; see fingerprint in README.md for details

import asyncio
import json
from typing import Any, Coroutine

import pytest
import pytest_check.context_manager
from conftest import MATCHSPEC_OVERRIDE, ReconstructedOtelSpan, RunParams
from syrupy import SnapshotAssertion
from syrupy.matchers import path_type


def test_failure_response(
    response_json_failure: dict, snapshot_json: SnapshotAssertion
):
    error = response_json_failure["error"]
    trace = response_json_failure["trace"]
    assert isinstance(error, str)
    assert isinstance(trace, str)

    assert trace.startswith("Traceback (most recent call last):\n ")
    assert trace.strip().endswith(error)

    exclude_trace = {"trace": (str,)}
    matcher = path_type(exclude_trace)
    assert response_json_failure == snapshot_json(matcher=matcher)


def test_dashboard_json(
    no_data: bool, response_json_success: dict, snapshot_json: SnapshotAssertion
):
    if no_data:
        kws = {}
    else:
        exclude_results_data = {
            f"result.views.{key}.{i}.data": (str,)
            for key in response_json_success["result"]["views"]
            for i, _ in enumerate(response_json_success["result"]["views"][key])
        }
        kws = {"matcher": path_type(exclude_results_data)}
    assert response_json_success == snapshot_json(**kws)


@pytest.mark.asyncio
async def test_iframes(
    snapshot_png: SnapshotAssertion,
    screenshot_coros: list[Coroutine[Any, Any, tuple[str, bytes]]],
    check: pytest_check.context_manager.CheckContextManager,
):
    screenshots = await asyncio.gather(*screenshot_coros)
    assert len(screenshots) == len(screenshot_coros)
    for widget_title, actual_png in screenshots:
        with check:
            assert actual_png == snapshot_png(name=widget_title.replace(" ", "_"))


def test_otel_traces_success(
    otel_traces_success: list[ReconstructedOtelSpan],
    run_params: RunParams,
):
    # TODO: what about failure?

    # the root span is created in the test fixture that runs the workflow; it's used
    # to confirm traceparent propagation from an outside caller into the app/cli
    root_span = next(s for s in otel_traces_success if s.parent_id is None)
    assert root_span.name == "response_json_success_pytest_fixture"
    assert (
        root_span.attributes["this simulates"]
        == "traceparent propagation from the FastAPI app"
    )

    # depending on api mode, the cli span is either a direct child of the root span
    # (cli mode) or there's an intermediate app request span (app mode) between them
    match run_params.api:
        case "cli":
            cli_parent_span = root_span
        case "app":
            # in app mode, there's an intermediate span created in the app that
            # represents the handling of the request - its parent is the root span
            app_request_span = next(
                s for s in otel_traces_success if s.parent_id == root_span.span_id
            )
            assert app_request_span.name == "run-endpoint"
            assert set(app_request_span.attributes.keys()) == {
                "workflow_run_id",
                "invoker_type",
            }
            cli_parent_span = app_request_span
        case _:
            raise ValueError(f"Unknown api mode in run params: {run_params}")

    # the cli span represents the entire workflow execution via cli. it is either the child of
    # the root span (cli mode) or the app request span (app mode)
    # - its name is the workflow name with .cli suffix
    # - its attributes include execution_mode, mock_io, config.time_range, config.groupers
    # - config.time_range and config.groupers are JSON-dumps of respective config sections
    cli_span = next(
        s
        for s in otel_traces_success
        if s.parent_id == cli_parent_span.span_id and s.name.endswith(".cli")
    )
    assert cli_span.name == f"{MATCHSPEC_OVERRIDE}.cli"
    assert cli_span.attributes["execution_mode"] == "sequential"
    assert cli_span.attributes["mock_io"] is True
    assert "config.time_range" in cli_span.attributes
    assert "config.groupers" in cli_span.attributes
    time_range: dict = json.loads(cli_span.attributes["config.time_range"])
    groupers: dict = json.loads(cli_span.attributes["config.groupers"])
    assert set(time_range.keys()) == {"since", "timezone", "until"}
    assert set(groupers.keys()) == {"groupers"}
    assert cli_span.status == {"status_code": "UNSET"}
    # spans one level below `.cli` span represent task instances
    # - their names are the task instance ids
    # - their attributes include the task method used (call, map, mapvalues)
    task_instance_spans = [
        s for s in otel_traces_success if s.parent_id == cli_span.span_id
    ]
    assert task_instance_spans[0].name == "workflow_details"
    assert all(
        s.attributes.get("method") in {"call", "map", "mapvalues"}
        for s in task_instance_spans
    )
    # spans below task instance spans represent function calls within tasks
    # - their names are the function names
    # - their attributes include func.__name__ and func.__module__
    task_function_call_spans = [
        s
        for s in otel_traces_success
        if s.parent_id in {ts.span_id for ts in task_instance_spans}
    ]
    assert all(
        (
            s.attributes.get("func.__name__") is not None
            and s.attributes.get("func.__module__") is not None
        )
        for s in task_function_call_spans
    )
    # and their names should match the function name attribute
    assert all(
        s.name == s.attributes["func.__name__"] for s in task_function_call_spans
    )
